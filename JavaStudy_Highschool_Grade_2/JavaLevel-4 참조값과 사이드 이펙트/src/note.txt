java.lang 패키지
- 자바가 기본으로 제공하는 라이브러리(클래스 모음) 중에 가장 기본이 되는 것
- lang = Language의 줄임마
- 자바 언어를 이루는 가장 기본이 되는 클래스를 보관하는 패키지

    java.lang 패키지의 대표적인 클래스
1. Object : 모든 자바 객체의 부모 클래스
2. String : 문자열
3. Integer Long Double : 랩퍼 타입, 기본형 데이터 타입을 객체로 만든 것
4. Class : 클래스 메타 정보
5. System : 시스템과 관련된 기본 기능들을 제공
- 위 클래스들은 자바 언어의 기본을 다루기 때문에 반드시 알고 넘어가야 한다.

import 생략 가능
-  java.lang 패키지는 모든 자바 애플리케이션에 자동으로 임포트(import) 된다.
- 따라서 임포트 구문을 사용하지 않아도 된다.

Object 클래스
- 자바에서 모든 클래스의 최상의 부모 클래스는 항상 Object Class 이다.

자바에서 Object Class 가 최상위 부모 클래스인 이유
1. 곡통 기능 제공
- 객체의 정보를 제공하고, 이 객체가 다른 객체와 같은지 비교하고, 객체가 어떤 클래스로 만들어졌는지 확인하는 기능ㅇㄴ 모든 객체가 필요하는 기능이다.
  이런 기능을 객체를 만들때 마다 항상 새로운 메서드를 정의해서 만들어야 한다면 상당히 번거로울 것이다.
- 막상 만든다고 해도 개발자마다 서로 다른 이름의 메서드를 만들어서 일관성이 없을 것이다.
- 개발자는 모든 객체가 앞ㅇ서 설명한 메서드를 지원하다는 것을 알고 있다. 따라서 프로그래밍이 단순화되고,
  일관성을 갖게 된다.

2. 다형성의 기본 구조
- 부모는 자식을 담을 수 있다. Object는 모든 클래스의 부모 클래스이다. 따라서 모든 객체를 참조할 수 있다.
- 모든 자바 객체는 Object 타입으로 처리할 수 있으며, 이는 다양한 타입의 객체를 통합적으로 관리할 수 이싿.
- Object는 모든 객체를 담을 수 있기에 타입에 다른 객체들을 어딘가에 보관해야 한다면 Object에 보관하면 된다.

Obejct 다형성
- 모든 클래스의 부모 클래스이다 따라서 Object는 모든 객체를 참조할 수 있다.

Obejct를 활용한 다형성의 한계
- Object는 모든 객체를 대상으로 다형적 참조가 가능하다.
    - 즉 Object는 모든 객체의 부모이므로 객체를 담을 수 있다.
- Object를 통해 전달 받은 객체를 호출하려면 각 객체에 맞는 다운 캐스팅 과정이 필요하다
    - Object가 세상의 모든 메서드를 알고 있는게 아니다.

다형성을 제대로 활용하려면 다형적 참조 + 메서드 오버라이딩을 함께 사용해야 한다.
Object는 모든 객체의 부모이므로 모든 객체를 대상으로 다형적 참조를 할 수 있다.
하지만 Object에는 Dog.sound(), Car.move()와 같은 다른 객체의 메서드가 정의되어 있지 않다.
따라서 메서드 오버라이딩을 활용할 수 없다.
결국 각 객체의 기능을 호출하려면 다운캐스팅을 해야한다.

결론
다형적 참조는 가능하지만, 메서드 오버라이딩이 안되기 때문에 다형성을 활용하기엔 한계가 있다.

Object 배열
- Object[]을 하면 세사엥 모든 객체들을 담을 수 있다.

Object가 없다면
1. void action(Object object)과 같이 모든 객체를 받을 수 있는 메서드를 만들 수 없다.
2. Object[] objects 처럼 모든 객체를 저장할 수 있는 배열을 만들 수 없다.
3. MyObject와 같은 클래스를 만들고 모든 클래스에서 직접 정의한 MyObject를 상속받으면 해당 기능을 구현할 수 있지만,
   하나의 프로젝트를 넘어 전세계 모든 개발자가 비슷한 클래스를 만들 것이고, 서로 호환되지 않는 수많은
   XxxObject들이 넘쳐날 것이다.

이 경우 물리적으로 다른 메모리에 있는 다른 객체이지만, 회원 번호를 기준으로 생각해보면 논리적으로 같은 회원으로 볼 수 있다.
따라서 동일성은 다르지만, 동등성은 같다.

Object의 나머지 메서드
1. clone() -> 객체를 복사할 때 사용한다. (잘 사용하지 않는다.)
2. hashCode() -> equals(0와 hashCode() 종종 함께 사용된다. -> 컬랙션 프레임워크 때 설명
3. getClass() -> class 다룰 때 설명4. ntify(), notifyAll(), wait() -> 멀티 쓰레드용 메서드 -> 멀티 쓰레드에서 설명

equals() 메서드를 구현할 때 지켜야 하는 규칙
1. 반사성: 객체는 자기 자신과 동등해야 한다. (x.equals(x) 는 항상 true)
2. 대칭성: 두 객체가 서로에 대해 동일하다고 판단하면, 이는 양방향으로 동일해야 한다.
(x.equals(y) 가 true이면 y.equals(x)도 true)
3. 추이성: 만약 한 객체가 두 번째 객체와 동일하고, 두 번째 객체가 세 번째 객체와 동일하다면, 첫 번째 객체는 세 번째 객체는 동일해야 한다.
4. 일관성: 두 객체의 상태가 변경되지 않는 한, equals() 메소드는 항상 동일한 값을 반환해야 한다.
5. null에 대한 비교: 모든 객체는 null과 비교했을 떄 false를 반환해야 한다.